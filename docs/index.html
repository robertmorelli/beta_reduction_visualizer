<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lambda Calculus Beta Reducer</title>
  <link rel="icon" type="image/svg+xml" href="favicon-green.svg">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="header">
    <h1>Lambda Calculus Beta Reducer</h1>
    <div class="header-actions">
      <button class="header-btn primary" onclick="showExamples()">Examples</button>
      <button class="header-btn" onclick="resetConversation()">Clear</button>
    </div>
  </div>

  <div class="conversation" id="conversation">
    <div class="message system-message">
      Enter a lambda expression below or choose from examples to begin.
      <br><br>
      <strong>Syntax:</strong> <code>\x.body</code> or <code>&#955;x.body</code> for lambda, <code>(f x)</code> for application
    </div>
  </div>

  <div class="input-area">
    <div class="input-row">
      <input type="text" id="lambda-input" placeholder="Enter lambda expression, e.g., (\x.x) hello" autofocus>
      <button onclick="submitExpression()">Reduce</button>
    </div>
    <div class="help-text">
      Type a reduction number to reduce that redex, or enter a new expression to start fresh.
    </div>
  </div>

  <div class="modal-overlay" id="examples-modal" onclick="hideExamples(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <h2>Choose an Example</h2>
      <div class="examples-list" id="examples-list"></div>
    </div>
  </div>

  <script>
    // ============================================================================
    // Kernel - Lambda Calculus Core (embedded for static hosting)
    // ============================================================================

    class Variable {
      constructor(name, fromSubstitution = false, sourceId = null) {
        this.type = 'variable';
        this.name = name;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Variable(
          this.name,
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Abstraction {
      constructor(param, body, fromSubstitution = false, sourceId = null) {
        this.type = 'abstraction';
        this.param = param;
        this.body = body;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Abstraction(
          this.param,
          this.body.clone(fromSubstitution, sourceId),
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Application {
      constructor(func, arg, id = null, fromSubstitution = false, sourceId = null) {
        this.type = 'application';
        this.func = func;
        this.arg = arg;
        this.id = id;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Application(
          this.func.clone(fromSubstitution, sourceId),
          this.arg.clone(fromSubstitution, sourceId),
          this.id,
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Parser {
      constructor(input) {
        this.input = input.trim();
        this.pos = 0;
      }

      peek() { return this.input[this.pos]; }
      consume() { return this.input[this.pos++]; }

      skipWhitespace() {
        while (this.pos < this.input.length && /\s/.test(this.peek())) {
          this.pos++;
        }
      }

      parseVariable() {
        let name = '';
        while (this.pos < this.input.length && /[a-zA-Z0-9_']/.test(this.peek())) {
          name += this.consume();
        }
        if (name === '') throw new Error(`Expected variable at position ${this.pos}`);
        return new Variable(name);
      }

      parseAtom() {
        this.skipWhitespace();
        const ch = this.peek();

        if (ch === '(') {
          this.consume();
          const expr = this.parseExpr();
          this.skipWhitespace();
          if (this.peek() !== ')') throw new Error(`Expected ')' at position ${this.pos}`);
          this.consume();
          return expr;
        }

        if (ch === '\u03BB' || ch === '\\') {
          this.consume();
          this.skipWhitespace();
          const param = this.parseVariable().name;
          this.skipWhitespace();
          if (this.peek() !== '.') throw new Error(`Expected '.' after lambda parameter`);
          this.consume();
          const body = this.parseExpr();
          return new Abstraction(param, body);
        }

        if (/[a-zA-Z]/.test(ch)) return this.parseVariable();
        throw new Error(`Unexpected character '${ch}' at position ${this.pos}`);
      }

      parseExpr() {
        this.skipWhitespace();
        let left = this.parseAtom();

        while (true) {
          this.skipWhitespace();
          const ch = this.peek();
          if (ch === undefined || ch === ')') break;
          if (ch === '(' || ch === '\u03BB' || ch === '\\' || /[a-zA-Z]/.test(ch)) {
            const right = this.parseAtom();
            left = new Application(left, right);
          } else break;
        }
        return left;
      }

      parse() {
        const result = this.parseExpr();
        this.skipWhitespace();
        if (this.pos < this.input.length) throw new Error(`Unexpected character at position ${this.pos}`);
        return result;
      }
    }

    function parse(input) { return new Parser(input).parse(); }

    function freeVariables(expr) {
      switch (expr.type) {
        case 'variable': return new Set([expr.name]);
        case 'abstraction':
          const bodyFree = freeVariables(expr.body);
          bodyFree.delete(expr.param);
          return bodyFree;
        case 'application':
          return new Set([...freeVariables(expr.func), ...freeVariables(expr.arg)]);
      }
    }

    function freshName(name, avoid) {
      let fresh = name;
      while (avoid.has(fresh)) fresh += "'";
      return fresh;
    }

    function substitute(expr, varName, replacement, markAsSubstituted = true, sourceId = null) {
      switch (expr.type) {
        case 'variable':
          if (expr.name === varName) return replacement.clone(markAsSubstituted, sourceId);
          return expr;

        case 'abstraction':
          if (expr.param === varName) return expr;
          const replFree = freeVariables(replacement);
          if (replFree.has(expr.param)) {
            const allFree = new Set([...replFree, ...freeVariables(expr.body)]);
            allFree.add(varName);
            const newParam = freshName(expr.param, allFree);
            const renamedBody = substitute(expr.body, expr.param, new Variable(newParam), false, null);
            return new Abstraction(newParam, substitute(renamedBody, varName, replacement, markAsSubstituted, sourceId), expr.fromSubstitution, expr.sourceId);
          }
          return new Abstraction(expr.param, substitute(expr.body, varName, replacement, markAsSubstituted, sourceId), expr.fromSubstitution, expr.sourceId);

        case 'application':
          return new Application(
            substitute(expr.func, varName, replacement, markAsSubstituted, sourceId),
            substitute(expr.arg, varName, replacement, markAsSubstituted, sourceId),
            expr.id, expr.fromSubstitution, expr.sourceId
          );
      }
    }

    function isRedex(expr) {
      return expr.type === 'application' && expr.func.type === 'abstraction';
    }

    function numberRedexes(expr, counter = { val: 1 }) {
      switch (expr.type) {
        case 'variable': return expr;
        case 'abstraction':
          return new Abstraction(expr.param, numberRedexes(expr.body, counter), expr.fromSubstitution, expr.sourceId);
        case 'application':
          let id = null;
          if (isRedex(expr)) id = counter.val++;
          return new Application(numberRedexes(expr.func, counter), numberRedexes(expr.arg, counter), id, expr.fromSubstitution, expr.sourceId);
      }
    }

    function clearSubstitutionMarks(expr) {
      switch (expr.type) {
        case 'variable': return new Variable(expr.name, false, null);
        case 'abstraction': return new Abstraction(expr.param, clearSubstitutionMarks(expr.body), false, null);
        case 'application':
          return new Application(clearSubstitutionMarks(expr.func), clearSubstitutionMarks(expr.arg), expr.id, false, null);
      }
    }

    function reduceAt(expr, targetId) {
      switch (expr.type) {
        case 'variable': return expr;
        case 'abstraction':
          return new Abstraction(expr.param, reduceAt(expr.body, targetId), expr.fromSubstitution, expr.sourceId);
        case 'application':
          if (expr.id === targetId && isRedex(expr)) {
            const lambda = expr.func;
            return substitute(lambda.body, lambda.param, expr.arg, true, targetId);
          }
          return new Application(reduceAt(expr.func, targetId), reduceAt(expr.arg, targetId), expr.id, expr.fromSubstitution, expr.sourceId);
      }
    }

    function getRedexCount(expr) {
      let count = 0;
      function traverse(e) {
        if (e.type === 'application') {
          if (isRedex(e)) count++;
          traverse(e.func);
          traverse(e.arg);
        } else if (e.type === 'abstraction') {
          traverse(e.body);
        }
      }
      traverse(expr);
      return count;
    }

    function toPlainString(expr) {
      switch (expr.type) {
        case 'variable': return expr.name;
        case 'abstraction': return `\u03BB${expr.param}.${toPlainString(expr.body)}`;
        case 'application': return `(${toPlainString(expr.func)} ${toPlainString(expr.arg)})`;
      }
    }

    const EXAMPLES = [
      { name: 'Identity', description: 'The simplest function - returns its argument', expr: '(\\x.x) hello' },
      { name: 'K Combinator', description: 'Takes two args, returns the first (TRUE)', expr: '(\\x.\\y.x) first second' },
      { name: 'S Combinator', description: 'The universal combinator - substitution', expr: '(\\x.\\y.\\z.x z (y z)) a b c' },
      { name: 'Church Numeral 2', description: 'Number 2 applied to successor and zero', expr: '(\\f.\\x.f (f x)) (\\n.succ n) zero' },
      { name: 'Boolean AND', description: 'TRUE AND FALSE = FALSE', expr: '(\\p.\\q.p q p) (\\x.\\y.x) (\\x.\\y.y)' },
      { name: 'Boolean OR', description: 'FALSE OR TRUE = TRUE', expr: '(\\p.\\q.p p q) (\\x.\\y.y) (\\x.\\y.x)' },
      { name: 'Church Addition', description: 'Add 2 + 2 in Church numerals', expr: '(\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x)) s z' },
      { name: 'Omega', description: 'Self-application - infinite loop', expr: '(\\x.x x) (\\x.x x)' },
    ];

    // ============================================================================
    // Web UI - Chat-like Interface
    // ============================================================================

    // ============================================================================
    // Variable Usage Detection (for discarded arg indicator)
    // ============================================================================

    function variableAppearsIn(expr, varName) {
      switch (expr.type) {
        case 'variable':
          return expr.name === varName;
        case 'abstraction':
          if (expr.param === varName) return false;
          return variableAppearsIn(expr.body, varName);
        case 'application':
          return variableAppearsIn(expr.func, varName) || variableAppearsIn(expr.arg, varName);
      }
    }

    function isArgumentUsed(redexExpr) {
      if (!isRedex(redexExpr)) return false;
      const lambda = redexExpr.func;
      return variableAppearsIn(lambda.body, lambda.param);
    }

    function getRedex(expr, redexId) {
      function find(e) {
        switch (e.type) {
          case 'variable': return null;
          case 'abstraction': return find(e.body);
          case 'application':
            if (e.id === redexId && isRedex(e)) return e;
            return find(e.func) || find(e.arg);
        }
      }
      return find(expr);
    }

    // ============================================================================
    // Web UI - Chat-like Interface
    // ============================================================================

    // Global state
    // Steps include: expr, exprString, reducedId, stepNum, discardedArg (if arg wasn't used)
    let steps = [];
    let currentExpr = null;

    function getDepthClass(depth) {
      return `depth-${depth % 7}`;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Render expression to HTML string (for use inside pre element)
    // Uses colored parentheses and wraps substituted subtrees in a single box
    // nextReducedId: if the next step reduced a redex, this is its id (for source highlighting)
    function renderExprToHTML(expr, depth, stepIndex, inSubstitution, nextReducedId, redexClickHandler) {
      const depthClass = getDepthClass(depth);

      // Check if this node starts a substitution (is substituted but parent wasn't)
      const startsSubstitution = expr.fromSubstitution && !inSubstitution;

      if (startsSubstitution) {
        // Wrap the entire substituted subtree in one box
        const wrapper = document.createElement('span');
        wrapper.className = 'substitution-box';
        wrapper.dataset.sourceId = expr.sourceId;
        wrapper.dataset.stepIndex = stepIndex;

        // Render the content inside (now we're "in" a substitution)
        const inner = renderExprToHTML(expr, depth, stepIndex, true, nextReducedId, redexClickHandler);
        wrapper.appendChild(inner);
        return wrapper;
      }

      switch (expr.type) {
        case 'variable': {
          const span = document.createElement('span');
          span.textContent = expr.name;
          return span;
        }

        case 'abstraction': {
          const container = document.createDocumentFragment();
          const lambdaText = document.createElement('span');
          lambdaText.textContent = '\u03BB' + expr.param + '.';
          container.appendChild(lambdaText);
          container.appendChild(renderExprToHTML(expr.body, depth, stepIndex, inSubstitution, nextReducedId, redexClickHandler));
          return container;
        }

        case 'application': {
          const container = document.createDocumentFragment();

          const openParen = document.createElement('span');
          openParen.className = `paren ${depthClass}`;
          openParen.textContent = '(';

          const closeParen = document.createElement('span');
          closeParen.className = `paren ${depthClass}`;
          closeParen.textContent = ')';

          // Wrap func and arg in spans so they're always single elements
          const funcWrapper = document.createElement('span');
          funcWrapper.className = 'func';
          funcWrapper.appendChild(renderExprToHTML(expr.func, depth + 1, stepIndex, inSubstitution, nextReducedId, redexClickHandler));

          const argWrapper = document.createElement('span');
          argWrapper.className = 'arg';
          // Add data attributes for linking if this is a redex
          if (expr.id !== null) {
            argWrapper.dataset.redexId = expr.id;
            argWrapper.dataset.stepIndex = stepIndex;
            // If next step reduced this redex, highlight the argument as source
            if (expr.id === nextReducedId) {
              argWrapper.classList.add('source-highlight');
            }
          }
          argWrapper.appendChild(renderExprToHTML(expr.arg, depth + 1, stepIndex, inSubstitution, nextReducedId, redexClickHandler));

          container.appendChild(openParen);
          container.appendChild(funcWrapper);
          container.appendChild(document.createTextNode(' '));
          container.appendChild(argWrapper);
          container.appendChild(closeParen);

          // Add redex indicator if this is a redex
          if (expr.id !== null) {
            const indicator = document.createElement('span');
            indicator.className = `redex-indicator ${depthClass}`;
            indicator.textContent = expr.id;
            indicator.title = `Reduce redex ${expr.id}`;
            indicator.onclick = (e) => {
              e.stopPropagation();
              redexClickHandler(expr.id);
            };
            container.appendChild(indicator);
          }

          return container;
        }
      }
    }

    function createStepMessage(step, stepIndex) {
      const msg = document.createElement('div');
      msg.className = 'message';
      msg.dataset.stepIndex = stepIndex;

      // Header
      const header = document.createElement('div');
      header.className = 'message-header';

      const badge = document.createElement('span');
      badge.className = 'step-badge';
      badge.textContent = step.stepNum === 0 ? 'Start' : `Step ${step.stepNum}`;
      header.appendChild(badge);

      if (step.reducedId !== null) {
        const info = document.createElement('span');
        info.className = 'reduction-info';
        info.textContent = `reduced [${step.reducedId}]`;
        header.appendChild(info);

        // Show discarded arg indicator if the argument wasn't used
        if (step.discardedArg !== null) {
          const discarded = document.createElement('span');
          discarded.className = 'discarded-arg';
          discarded.title = 'Argument not used in function body (discarded)';
          discarded.innerHTML = `<span class="discarded-label">discarded:</span> <code>${escapeHtml(step.discardedArg)}</code>`;
          header.appendChild(discarded);
        }
      }

      msg.appendChild(header);

      // Expression content in pre element
      const content = document.createElement('div');
      content.className = 'expression-content';

      // Check if next step reduced a redex from this step (for source highlighting)
      const nextReducedId = steps[stepIndex + 1]?.reducedId ?? null;

      const pre = document.createElement('pre');
      pre.className = 'expression-pre';
      pre.appendChild(renderExprToHTML(step.expr, 0, stepIndex, false, nextReducedId, handleReduce));
      content.appendChild(pre);
      msg.appendChild(content);

      // Redex choices (only for most recent step)
      const redexCount = getRedexCount(step.expr);
      if (stepIndex === steps.length - 1) {
        const redexLine = document.createElement('div');
        redexLine.className = 'redex-line';

        if (redexCount === 0) {
          const normalBadge = document.createElement('span');
          normalBadge.className = 'normal-form-badge';
          normalBadge.textContent = 'Normal form reached';
          redexLine.appendChild(normalBadge);
        } else {
          const label = document.createElement('span');
          label.className = 'redex-label';
          label.textContent = 'Reduce:';
          redexLine.appendChild(label);

          for (let i = 1; i <= redexCount; i++) {
            const btn = document.createElement('button');
            btn.className = `redex-choice ${getDepthClass(i - 1)}`;
            btn.textContent = `[${i}]`;
            btn.onclick = () => handleReduce(i);
            redexLine.appendChild(btn);
          }
        }

        msg.appendChild(redexLine);
      }

      return msg;
    }

    function renderConversation() {
      const conv = document.getElementById('conversation');
      conv.innerHTML = '';

      if (steps.length === 0) {
        const sysMsg = document.createElement('div');
        sysMsg.className = 'message system-message';
        sysMsg.innerHTML = `
          Enter a lambda expression below or choose from examples to begin.
          <br><br>
          <strong>Syntax:</strong> <code>\\x.body</code> or <code>\u03BBx.body</code> for lambda, <code>(f x)</code> for application
        `;
        conv.appendChild(sysMsg);
      } else {
        steps.forEach((step, i) => {
          conv.appendChild(createStepMessage(step, i));
        });
      }

      // Setup hover highlighting for substitution boxes
      setupSubstitutionHover();

      // Scroll to bottom
      conv.scrollTop = conv.scrollHeight;
    }

    function setupSubstitutionHover() {
      // Clear all highlights helper
      function clearHighlights() {
        document.querySelectorAll('.substitution-box.highlight').forEach(s => {
          s.classList.remove('highlight');
        });
        document.querySelectorAll('.source-hover').forEach(s => {
          s.classList.remove('source-hover');
        });
      }

      // Hover on RED boxes highlights:
      // 1. All red boxes from the same source in the same step
      // 2. The corresponding yellow source box in the previous step
      const redBoxes = document.querySelectorAll('.substitution-box');
      redBoxes.forEach(el => {
        const sourceId = el.dataset.sourceId;
        const stepIndex = parseInt(el.dataset.stepIndex);

        el.addEventListener('mouseenter', () => {
          // Highlight all red boxes with same source in current step
          document.querySelectorAll(`.substitution-box[data-source-id="${sourceId}"][data-step-index="${stepIndex}"]`).forEach(s => {
            s.classList.add('highlight');
          });

          // Highlight the corresponding yellow source box in previous step
          // The sourceId tells us which redex was reduced to create this substitution
          // That redex existed in step (stepIndex - 1) with id = sourceId
          if (stepIndex > 0) {
            const prevStepIndex = stepIndex - 1;
            // Find the arg wrapper for that redex in the previous step
            const sourceArg = document.querySelector(`.arg[data-redex-id="${sourceId}"][data-step-index="${prevStepIndex}"]`);
            if (sourceArg) {
              sourceArg.classList.add('source-hover');
            }
          }
        });

        el.addEventListener('mouseleave', clearHighlights);
      });

      // Hover on YELLOW boxes highlights:
      // All corresponding red boxes in the next step
      const yellowBoxes = document.querySelectorAll('.source-highlight');
      yellowBoxes.forEach(el => {
        el.addEventListener('mouseenter', () => {
          const redexId = el.dataset.redexId;
          const stepIndex = parseInt(el.dataset.stepIndex);

          if (redexId !== undefined) {
            const nextStepIndex = stepIndex + 1;
            // Highlight all red boxes in next step that came from this redex
            document.querySelectorAll(`.substitution-box[data-source-id="${redexId}"][data-step-index="${nextStepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });
          }
          // Also highlight this yellow box
          el.classList.add('source-hover');
        });

        el.addEventListener('mouseleave', clearHighlights);
      });
    }

    function handleReduce(id) {
      if (!currentExpr || steps.length === 0) return;

      // Clear marks on currentExpr before reducing (so new marks are fresh)
      currentExpr = clearSubstitutionMarks(currentExpr);
      currentExpr = numberRedexes(currentExpr);

      // Check if the argument will be used (before reducing)
      const redex = getRedex(currentExpr, id);
      const wasUsed = redex ? isArgumentUsed(redex) : true;
      const discardedArg = !wasUsed && redex ? toPlainString(redex.arg) : null;

      // Perform reduction - this adds substitution marks
      currentExpr = reduceAt(currentExpr, id);
      currentExpr = numberRedexes(currentExpr);

      // Add new step - keep substitution marks for history
      steps.push({
        expr: currentExpr,
        exprString: toPlainString(currentExpr),
        reducedId: id,
        stepNum: steps.length,
        discardedArg  // null if used, otherwise the string representation
      });

      renderConversation();
    }

    function loadExpression(exprString) {
      try {
        currentExpr = parse(exprString);
        currentExpr = numberRedexes(currentExpr);

        steps = [{
          expr: currentExpr,
          exprString: exprString,
          reducedId: null,
          stepNum: 0
        }];

        renderConversation();
        document.getElementById('lambda-input').value = '';
      } catch (e) {
        // Show error as system message
        const conv = document.getElementById('conversation');
        const errMsg = document.createElement('div');
        errMsg.className = 'message system-message';
        errMsg.textContent = `Parse error: ${e.message}`;
        errMsg.style.color = '#ff6b6b';
        conv.appendChild(errMsg);
        conv.scrollTop = conv.scrollHeight;
      }
    }

    function submitExpression() {
      const input = document.getElementById('lambda-input');
      const value = input.value.trim();

      if (!value) return;

      // Check if it's a number (redex selection)
      const num = parseInt(value, 10);
      if (!isNaN(num) && currentExpr) {
        const redexCount = getRedexCount(currentExpr);
        if (num >= 1 && num <= redexCount) {
          input.value = '';
          handleReduce(num);
          return;
        }
      }

      // Otherwise treat as new expression
      loadExpression(value);
    }

    function resetConversation() {
      steps = [];
      currentExpr = null;
      renderConversation();
      document.getElementById('lambda-input').focus();
    }

    function showExamples() {
      document.getElementById('examples-modal').classList.add('visible');
    }

    function hideExamples(e) {
      if (e.target.id === 'examples-modal') {
        document.getElementById('examples-modal').classList.remove('visible');
      }
    }

    function selectExample(expr) {
      document.getElementById('examples-modal').classList.remove('visible');
      loadExpression(expr);
    }

    // Initialize
    function init() {
      // Populate examples
      const list = document.getElementById('examples-list');
      EXAMPLES.forEach(ex => {
        const item = document.createElement('div');
        item.className = 'example-item';
        item.innerHTML = `
          <div class="name">${ex.name}</div>
          <div class="desc">${ex.description}</div>
          <div class="expr">${ex.expr}</div>
        `;
        item.onclick = () => selectExample(ex.expr);
        list.appendChild(item);
      });

      // Handle enter key
      document.getElementById('lambda-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitExpression();
      });

      renderConversation();
    }

    init();
  </script>
</body>
</html>
