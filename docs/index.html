<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lambda Calculus Beta Reducer</title>
  <link rel="icon" type="image/svg+xml" href="favicon-green.svg">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div class="header">
    <h1>Lambda Calculus Beta Reducer</h1>
    <div class="header-actions">
      <button class="header-btn clear-btn" id="clear-btn" onclick="resetConversation()"
        style="visibility: collapse;">Clear<span class="keybind-badge">esc</span></button>
    </div>
  </div>

  <div class="conversation" id="conversation">
    <div class="message system-message">
      Enter a lambda expression below or choose from examples to begin.
      <br><br>
      <strong>Syntax:</strong> <code>\x.body</code> or <code>&#955;x.body</code> for lambda, <code>(f x)</code> for
      application
    </div>
  </div>

  <div id="input-area">
    <div class="input-box examples-box"></div>
    <div class="input-box main-box"></div>
    <button class="examples-btn" onclick="showExamples()">Examples<span class="keybind-badge">ctrl-e</span></button>
    <button class="reduce-btn" onclick="submitExpression()">Reduce ❯<span class="keybind-badge">ctrl-r</span></button>
    <input type="text" id="lambda-input" placeholder="Enter lambda expression, e.g., (\x.x) hello" autofocus>
  </div>

  <div class="modal-overlay" id="examples-modal" onclick="hideExamples(event)">
    <div class="modal" onclick="event.stopPropagation()">
      <h2>Choose an Example</h2>
      <div class="examples-list" id="examples-list"></div>
    </div>
  </div>

  <script>
    // ============================================================================
    // Kernel - Lambda Calculus Core (embedded for static hosting)
    // ============================================================================

    class Variable {
      constructor(name, fromSubstitution = false, sourceId = null) {
        this.type = 'variable';
        this.name = name;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Variable(
          this.name,
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Abstraction {
      constructor(param, body, fromSubstitution = false, sourceId = null) {
        this.type = 'abstraction';
        this.param = param;
        this.body = body;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Abstraction(
          this.param,
          this.body.clone(fromSubstitution, sourceId),
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Application {
      constructor(func, arg, id = null, fromSubstitution = false, sourceId = null) {
        this.type = 'application';
        this.func = func;
        this.arg = arg;
        this.id = id;
        this.fromSubstitution = fromSubstitution;
        this.sourceId = sourceId;
      }

      clone(fromSubstitution = false, sourceId = null) {
        return new Application(
          this.func.clone(fromSubstitution, sourceId),
          this.arg.clone(fromSubstitution, sourceId),
          this.id,
          fromSubstitution || this.fromSubstitution,
          sourceId !== null ? sourceId : this.sourceId
        );
      }
    }

    class Parser {
      constructor(input) {
        this.input = input.trim();
        this.pos = 0;
      }

      peek() { return this.input[this.pos]; }
      consume() { return this.input[this.pos++]; }

      skipWhitespace() {
        while (this.pos < this.input.length && /\s/.test(this.peek())) {
          this.pos++;
        }
      }

      parseVariable() {
        let name = '';
        while (this.pos < this.input.length && /[a-zA-Z0-9_']/.test(this.peek())) {
          name += this.consume();
        }
        if (name === '') throw new Error(`Expected variable at position ${this.pos}`);
        return new Variable(name);
      }

      parseAtom() {
        this.skipWhitespace();
        const ch = this.peek();

        if (ch === '(') {
          this.consume();
          const expr = this.parseExpr();
          this.skipWhitespace();
          if (this.peek() !== ')') throw new Error(`Expected ')' at position ${this.pos}`);
          this.consume();
          return expr;
        }

        if (ch === '\u03BB' || ch === '\\') {
          this.consume();
          this.skipWhitespace();
          const param = this.parseVariable().name;
          this.skipWhitespace();
          if (this.peek() !== '.') throw new Error(`Expected '.' after lambda parameter`);
          this.consume();
          const body = this.parseExpr();
          return new Abstraction(param, body);
        }

        if (/[a-zA-Z]/.test(ch)) return this.parseVariable();
        throw new Error(`Unexpected character '${ch}' at position ${this.pos}`);
      }

      parseExpr() {
        this.skipWhitespace();
        let left = this.parseAtom();

        while (true) {
          this.skipWhitespace();
          const ch = this.peek();
          if (ch === undefined || ch === ')') break;
          if (ch === '(' || ch === '\u03BB' || ch === '\\' || /[a-zA-Z]/.test(ch)) {
            const right = this.parseAtom();
            left = new Application(left, right);
          } else break;
        }
        return left;
      }

      parse() {
        const result = this.parseExpr();
        this.skipWhitespace();
        if (this.pos < this.input.length) throw new Error(`Unexpected character at position ${this.pos}`);
        return result;
      }
    }

    function parse(input) { return new Parser(input).parse(); }

    function freeVariables(expr) {
      switch (expr.type) {
        case 'variable': return new Set([expr.name]);
        case 'abstraction':
          const bodyFree = freeVariables(expr.body);
          bodyFree.delete(expr.param);
          return bodyFree;
        case 'application':
          return new Set([...freeVariables(expr.func), ...freeVariables(expr.arg)]);
      }
    }

    function freshName(name, avoid) {
      let fresh = name;
      while (avoid.has(fresh)) fresh += "'";
      return fresh;
    }

    function substitute(expr, varName, replacement, markAsSubstituted = true, sourceId = null) {
      switch (expr.type) {
        case 'variable':
          if (expr.name === varName) return replacement.clone(markAsSubstituted, sourceId);
          return expr;

        case 'abstraction':
          if (expr.param === varName) return expr;
          const replFree = freeVariables(replacement);
          if (replFree.has(expr.param)) {
            const allFree = new Set([...replFree, ...freeVariables(expr.body)]);
            allFree.add(varName);
            const newParam = freshName(expr.param, allFree);
            const renamedBody = substitute(expr.body, expr.param, new Variable(newParam), false, null);
            return new Abstraction(newParam, substitute(renamedBody, varName, replacement, markAsSubstituted, sourceId), expr.fromSubstitution, expr.sourceId);
          }
          return new Abstraction(expr.param, substitute(expr.body, varName, replacement, markAsSubstituted, sourceId), expr.fromSubstitution, expr.sourceId);

        case 'application':
          return new Application(
            substitute(expr.func, varName, replacement, markAsSubstituted, sourceId),
            substitute(expr.arg, varName, replacement, markAsSubstituted, sourceId),
            expr.id, expr.fromSubstitution, expr.sourceId
          );
      }
    }

    function isRedex(expr) {
      return expr.type === 'application' && expr.func.type === 'abstraction';
    }

    function numberRedexes(expr, counter = { val: 1 }) {
      switch (expr.type) {
        case 'variable': return expr;
        case 'abstraction':
          return new Abstraction(expr.param, numberRedexes(expr.body, counter), expr.fromSubstitution, expr.sourceId);
        case 'application':
          let id = null;
          if (isRedex(expr)) id = counter.val++;
          return new Application(numberRedexes(expr.func, counter), numberRedexes(expr.arg, counter), id, expr.fromSubstitution, expr.sourceId);
      }
    }

    function clearSubstitutionMarks(expr) {
      switch (expr.type) {
        case 'variable': return new Variable(expr.name, false, null);
        case 'abstraction': return new Abstraction(expr.param, clearSubstitutionMarks(expr.body), false, null);
        case 'application':
          return new Application(clearSubstitutionMarks(expr.func), clearSubstitutionMarks(expr.arg), expr.id, false, null);
      }
    }

    function reduceAt(expr, targetId) {
      switch (expr.type) {
        case 'variable': return expr;
        case 'abstraction':
          return new Abstraction(expr.param, reduceAt(expr.body, targetId), expr.fromSubstitution, expr.sourceId);
        case 'application':
          if (expr.id === targetId && isRedex(expr)) {
            const lambda = expr.func;
            return substitute(lambda.body, lambda.param, expr.arg, true, targetId);
          }
          return new Application(reduceAt(expr.func, targetId), reduceAt(expr.arg, targetId), expr.id, expr.fromSubstitution, expr.sourceId);
      }
    }

    function getRedexCount(expr) {
      let count = 0;
      function traverse(e) {
        if (e.type === 'application') {
          if (isRedex(e)) count++;
          traverse(e.func);
          traverse(e.arg);
        } else if (e.type === 'abstraction') {
          traverse(e.body);
        }
      }
      traverse(expr);
      return count;
    }

    function toPlainString(expr) {
      switch (expr.type) {
        case 'variable': return expr.name;
        case 'abstraction': return `\u03BB${expr.param}.${toPlainString(expr.body)}`;
        case 'application': return `(${toPlainString(expr.func)} ${toPlainString(expr.arg)})`;
      }
    }

    const EXAMPLES = [
      // ═══════════════════════════════════════════════════════════════════════
      // BASIC COMBINATORS
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Identity (I)', description: 'The simplest function - returns its argument unchanged', expr: '(\\x.x) hello' },
      { name: 'K Combinator', description: 'Returns first argument, discards second', expr: '(\\x.\\y.x) first second' },
      { name: 'KI Combinator', description: 'Returns second argument, discards first', expr: '(\\x.\\y.y) first second' },
      { name: 'S Combinator', description: 'Substitution: S f g x = f x (g x)', expr: '(\\f.\\g.\\x.f x (g x)) a b c' },
      { name: 'B Combinator', description: 'Composition: B f g x = f (g x)', expr: '(\\f.\\g.\\x.f (g x)) outer inner arg' },
      { name: 'C Combinator', description: 'Flip arguments: C f x y = f y x', expr: '(\\f.\\x.\\y.f y x) func first second' },
      { name: 'W Combinator', description: 'Duplicate: W f x = f x x', expr: '(\\f.\\x.f x x) func arg' },
      { name: 'SKK = I', description: 'SKK is equivalent to identity', expr: '(\\f.\\g.\\x.f x (g x)) (\\a.\\b.a) (\\a.\\b.a) test' },

      // ═══════════════════════════════════════════════════════════════════════
      // CHURCH BOOLEANS
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'TRUE', description: 'Church boolean true: selects first argument', expr: '(\\x.\\y.x) yes no' },
      { name: 'FALSE', description: 'Church boolean false: selects second argument', expr: '(\\x.\\y.y) yes no' },
      { name: 'NOT TRUE', description: 'Logical negation: NOT TRUE = FALSE', expr: '(\\p.p (\\x.\\y.y) (\\x.\\y.x)) (\\x.\\y.x)' },
      { name: 'NOT FALSE', description: 'Logical negation: NOT FALSE = TRUE', expr: '(\\p.p (\\x.\\y.y) (\\x.\\y.x)) (\\x.\\y.y)' },
      { name: 'AND (T, F)', description: 'Logical AND: TRUE AND FALSE = FALSE', expr: '(\\p.\\q.p q p) (\\x.\\y.x) (\\x.\\y.y)' },
      { name: 'AND (T, T)', description: 'Logical AND: TRUE AND TRUE = TRUE', expr: '(\\p.\\q.p q p) (\\x.\\y.x) (\\x.\\y.x)' },
      { name: 'OR (F, T)', description: 'Logical OR: FALSE OR TRUE = TRUE', expr: '(\\p.\\q.p p q) (\\x.\\y.y) (\\x.\\y.x)' },
      { name: 'OR (F, F)', description: 'Logical OR: FALSE OR FALSE = FALSE', expr: '(\\p.\\q.p p q) (\\x.\\y.y) (\\x.\\y.y)' },
      { name: 'XOR (T, T)', description: 'Exclusive OR: TRUE XOR TRUE = FALSE', expr: '(\\p.\\q.p (q (\\x.\\y.y) (\\x.\\y.x)) q) (\\x.\\y.x) (\\x.\\y.x)' },
      { name: 'XOR (T, F)', description: 'Exclusive OR: TRUE XOR FALSE = TRUE', expr: '(\\p.\\q.p (q (\\x.\\y.y) (\\x.\\y.x)) q) (\\x.\\y.x) (\\x.\\y.y)' },
      { name: 'IF-THEN-ELSE', description: 'Conditional: IF TRUE THEN a ELSE b = a', expr: '(\\p.\\a.\\b.p a b) (\\x.\\y.x) then else' },

      // ═══════════════════════════════════════════════════════════════════════
      // CHURCH NUMERALS
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Zero (0)', description: 'Church numeral 0: apply f zero times', expr: '(\\f.\\x.x) s z' },
      { name: 'One (1)', description: 'Church numeral 1: apply f once', expr: '(\\f.\\x.f x) s z' },
      { name: 'Two (2)', description: 'Church numeral 2: apply f twice', expr: '(\\f.\\x.f (f x)) s z' },
      { name: 'Three (3)', description: 'Church numeral 3: apply f three times', expr: '(\\f.\\x.f (f (f x))) s z' },
      { name: 'SUCC 2', description: 'Successor function: SUCC 2 = 3', expr: '(\\n.\\f.\\x.f (n f x)) (\\f.\\x.f (f x)) s z' },
      { name: 'ADD 2 + 2', description: 'Addition: 2 + 2 = 4', expr: '(\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x)) s z' },
      { name: 'ADD 2 + 3', description: 'Addition: 2 + 3 = 5', expr: '(\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x))) s z' },
      { name: 'MULT 2 × 3', description: 'Multiplication: 2 × 3 = 6', expr: '(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x))) s z' },
      { name: 'MULT 2 × 2', description: 'Multiplication: 2 × 2 = 4', expr: '(\\m.\\n.\\f.m (n f)) (\\f.\\x.f (f x)) (\\f.\\x.f (f x)) s z' },
      { name: 'EXP 2^3', description: 'Exponentiation: 2^3 = 8', expr: '(\\m.\\n.n m) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x))) s z' },
      { name: 'EXP 3^2', description: 'Exponentiation: 3^2 = 9', expr: '(\\m.\\n.n m) (\\f.\\x.f (f (f x))) (\\f.\\x.f (f x)) s z' },
      { name: 'ISZERO 0', description: 'Test if zero: ISZERO 0 = TRUE', expr: '(\\n.n (\\x.\\a.\\b.b) (\\a.\\b.a)) (\\f.\\x.x) yes no' },
      { name: 'ISZERO 2', description: 'Test if zero: ISZERO 2 = FALSE', expr: '(\\n.n (\\x.\\a.\\b.b) (\\a.\\b.a)) (\\f.\\x.f (f x)) yes no' },

      // ═══════════════════════════════════════════════════════════════════════
      // PAIRS AND DATA STRUCTURES
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'PAIR', description: 'Create a pair and extract with selector', expr: '(\\x.\\y.\\f.f x y) first second (\\a.\\b.a)' },
      { name: 'FST', description: 'Extract first element of pair', expr: '(\\p.p (\\x.\\y.x)) ((\\a.\\b.\\f.f a b) first second)' },
      { name: 'SND', description: 'Extract second element of pair', expr: '(\\p.p (\\x.\\y.y)) ((\\a.\\b.\\f.f a b) first second)' },
      { name: 'SWAP', description: 'Swap elements of a pair', expr: '(\\p.(\\a.\\b.\\f.f a b) (p (\\x.\\y.y)) (p (\\x.\\y.x))) ((\\a.\\b.\\f.f a b) first second) (\\x.\\y.x)' },

      // ═══════════════════════════════════════════════════════════════════════
      // FIXED POINTS (NON-TERMINATING)
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Omega (ω)', description: 'Classic self-application loop: never terminates', expr: '(\\x.x x) (\\x.x x)' },
      { name: 'Omega Variant', description: 'Same loop, different variable names', expr: '(\\x.x x) (\\y.y y)' },
      { name: 'Big Omega (Ω)', description: 'Triple self-application: grows without bound', expr: '(\\x.x x x) (\\x.x x x)' },
      { name: 'Huge Omega', description: 'Quadruple self-application: explodes rapidly', expr: '(\\x.x x x x) (\\x.x x x x)' },
      { name: 'Y Combinator', description: 'Curry\'s fixed point combinator: Y f = f (Y f)', expr: '(\\f.(\\x.f (x x)) (\\x.f (x x))) g' },
      { name: 'Y Applied', description: 'Y combinator unfolding one step', expr: '(\\x.(\\a.a) (x x)) (\\x.(\\a.a) (x x))' },
      { name: 'Θ (Theta)', description: 'Turing\'s fixed point combinator', expr: '(\\x.\\f.f (x x f)) (\\x.\\f.f (x x f)) g' },
      { name: 'Z Combinator', description: 'Call-by-value Y combinator variant', expr: '(\\f.(\\x.f (\\v.x x v)) (\\x.f (\\v.x x v))) g' },
      { name: 'Simple Loop', description: 'The simplest infinite loop', expr: '(\\x.x x) (\\x.x x)' },
      { name: 'Nested Omega', description: 'Omega with extra wrapping', expr: '(\\y.(\\x.x x) (\\x.x x)) dummy' },

      // ═══════════════════════════════════════════════════════════════════════
      // INTERESTING REDUCTIONS
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Multiple Substitution', description: 'Argument gets duplicated twice', expr: '(\\x.x x) (\\a.a)' },
      { name: 'Triple Substitution', description: 'Argument gets duplicated three times', expr: '(\\x.x x x) (\\a.a)' },
      { name: 'Discarded Argument', description: 'K combinator throws away the second arg', expr: '(\\x.\\y.x) keep discard' },
      { name: 'Double Discard', description: 'Discards two arguments', expr: '(\\x.\\y.\\z.x) keep discard1 discard2' },
      { name: 'Nested Reduction', description: 'Reduction inside a lambda body', expr: '\\outer.(\\inner.inner) value' },
      { name: 'Deep Nesting', description: 'Multiple layers of reduction', expr: '\\a.\\b.(\\x.x) ((\\y.y) c)' },
      { name: 'Composition Demo', description: 'Function composition: (f ∘ g)(x)', expr: '(\\f.\\g.\\x.f (g x)) (\\a.A a) (\\b.B b) input' },
      { name: 'Church Succ Demo', description: 'Successor on 1 gives 2', expr: '(\\n.\\f.\\x.f (n f x)) (\\f.\\x.f x) s z' },

      // ═══════════════════════════════════════════════════════════════════════
      // ADVANCED / EXOTIC
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Church Pred', description: 'Predecessor function (complex!)', expr: '(\\n.\\f.\\x.n (\\g.\\h.h (g f)) (\\u.x) (\\u.u)) (\\f.\\x.f (f (f x))) s z' },
      { name: 'PRED 1 = 0', description: 'Predecessor of 1 is 0', expr: '(\\n.\\f.\\x.n (\\g.\\h.h (g f)) (\\u.x) (\\u.u)) (\\f.\\x.f x) s z' },
      { name: 'Factorial Setup', description: 'Factorial-like recursion structure', expr: '(\\f.(\\x.f (x x)) (\\x.f (x x))) (\\rec.\\n.n)' },
      { name: 'Self-Apply Identity', description: 'Apply identity to itself', expr: '(\\x.x) (\\y.y)' },
      { name: 'Reverse Application', description: 'Apply argument to function', expr: '(\\f.\\x.x f) (\\a.a) func' },
      { name: 'Mockingbird (M)', description: 'Self-application combinator: M f = f f', expr: '(\\f.f f) (\\x.x)' },
      { name: 'Mockingbird on K', description: 'M K produces interesting behavior', expr: '(\\f.f f) (\\x.\\y.x)' },
      { name: 'Kestrel & Mockingbird', description: 'K M ω - mixing combinators', expr: '(\\x.\\y.x) (\\f.f f) (\\x.x x)' },
      { name: 'Starling Dance', description: 'S I I x = x x (self-application)', expr: '(\\f.\\g.\\x.f x (g x)) (\\a.a) (\\b.b) y' },
      { name: 'Eta Expansion', description: 'λx.f x is extensionally equal to f', expr: '(\\x.(\\y.y) x) arg' },

      // ═══════════════════════════════════════════════════════════════════════
      // MULTI-REDEX EXPRESSIONS (3+ reduction choices)
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Triple Redex', description: '3 simultaneous reduction choices', expr: '((\\a.a) x) ((\\b.b) y) ((\\c.c) z)' },
      { name: 'Four Redexes', description: '4 simultaneous reduction options', expr: '((\\a.a) w) ((\\b.b) x) ((\\c.c) y) ((\\d.d) z)' },
      { name: 'Five Redexes', description: '5 simultaneous reductions to choose from', expr: '((\\a.a) v) ((\\b.b) w) ((\\c.c) x) ((\\d.d) y) ((\\e.e) z)' },
      { name: 'Nested Multi', description: '4 redexes at different nesting levels', expr: '(\\f.f ((\\a.a) x)) ((\\b.b) ((\\c.c) y))' },
      { name: 'Parallel Apps', description: '3 independent applications', expr: '\\result.((\\a.a a) p) ((\\b.b b) q) ((\\c.c c) r)' },
      { name: 'Deep Multi-Redex', description: '5 nested redexes', expr: '(\\a.(\\b.(\\c.(\\d.(\\e.e) five) four) three) two) one' },
      { name: 'Wide Expression', description: '6 redexes in a row', expr: '((\\a.a) A) ((\\b.b) B) ((\\c.c) C) ((\\d.d) D) ((\\e.e) E) ((\\f.f) F)' },
      { name: 'Complex S', description: 'S combinator with multiple internal redexes', expr: '(\\x.\\y.\\z.x z (y z)) ((\\a.a) f) ((\\b.b) g) ((\\c.c) h)' },
      { name: 'Many-Armed', description: '4 different paths through reduction', expr: '((\\x.x) ((\\a.a) p)) ((\\y.y) ((\\b.b) q))' },
      { name: 'Combinator Mix', description: 'Multiple combinators ready to fire', expr: '((\\x.x) I) ((\\a.\\b.a) K) ((\\p.\\q.q) F) arg' },

      // ═══════════════════════════════════════════════════════════════════════
      // CHALLENGING EXPRESSIONS
      // ═══════════════════════════════════════════════════════════════════════
      { name: 'Church 2+3+1', description: 'Multiple additions: (2+3)+1 = 6', expr: '(\\m.\\n.\\f.\\x.m f (n f x)) ((\\m.\\n.\\f.\\x.m f (n f x)) (\\f.\\x.f (f x)) (\\f.\\x.f (f (f x)))) (\\f.\\x.f x) s z' },
      { name: 'Boolean Chain', description: 'AND (OR TRUE FALSE) TRUE', expr: '(\\p.\\q.p q p) ((\\p.\\q.p p q) (\\x.\\y.x) (\\x.\\y.y)) (\\x.\\y.x)' },
      { name: 'Pair of Pairs', description: 'Nested pair structure', expr: '(\\x.\\y.\\f.f x y) ((\\a.\\b.\\g.g a b) one two) ((\\c.\\d.\\h.h c d) three four) (\\p.\\q.p)' },
      { name: 'SUCC (SUCC 2)', description: 'Successor twice: SUCC(SUCC 2) = 4', expr: '(\\n.\\f.\\x.f (n f x)) ((\\n.\\f.\\x.f (n f x)) (\\f.\\x.f (f x))) s z' },
      { name: 'Fibonacci Setup', description: 'Structure for computing Fibonacci', expr: '(\\f.(\\x.f (x x)) (\\x.f (x x))) (\\rec.\\n.\\a.\\b.n a (rec (\\f.\\x.x) b (a b)))' },
    ];

    // ============================================================================
    // Web UI - Chat-like Interface
    // ============================================================================

    // ============================================================================
    // Variable Usage Detection (for discarded arg indicator)
    // ============================================================================

    function variableAppearsIn(expr, varName) {
      switch (expr.type) {
        case 'variable':
          return expr.name === varName;
        case 'abstraction':
          if (expr.param === varName) return false;
          return variableAppearsIn(expr.body, varName);
        case 'application':
          return variableAppearsIn(expr.func, varName) || variableAppearsIn(expr.arg, varName);
      }
    }

    function isArgumentUsed(redexExpr) {
      if (!isRedex(redexExpr)) return false;
      const lambda = redexExpr.func;
      return variableAppearsIn(lambda.body, lambda.param);
    }

    // Find all uses of a variable in an expression (respects shadowing)
    function findVariableUses(expr, varName) {
      const uses = [];
      function traverse(e) {
        switch (e.type) {
          case 'variable':
            if (e.name === varName) uses.push(e);
            break;
          case 'abstraction':
            if (e.param !== varName) traverse(e.body);
            break;
          case 'application':
            traverse(e.func);
            traverse(e.arg);
            break;
        }
      }
      traverse(expr);
      return uses;
    }

    // Get parameter uses for a redex (the variable occurrences that will be replaced)
    function getParameterUses(redexExpr) {
      if (!isRedex(redexExpr)) return [];
      const lambda = redexExpr.func;
      return findVariableUses(lambda.body, lambda.param);
    }

    function getRedex(expr, redexId) {
      function find(e) {
        switch (e.type) {
          case 'variable': return null;
          case 'abstraction': return find(e.body);
          case 'application':
            if (e.id === redexId && isRedex(e)) return e;
            return find(e.func) || find(e.arg);
        }
      }
      return find(expr);
    }

    // ============================================================================
    // Web UI - Chat-like Interface
    // ============================================================================

    // Global state
    // Steps include: expr, exprString, reducedId, stepNum, discardedArg (if arg wasn't used)
    let steps = [];
    let currentExpr = null;

    function getDepthClass(depth) {
      return `depth-${depth % 7}`;
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    // Render expression to HTML string (for use inside pre element)
    // Uses colored parentheses and wraps substituted subtrees in a single box
    // nextReducedId: if the next step reduced a redex, this is its id (for source highlighting)
    // paramUseNodes: Set of Variable nodes that are parameter uses (for blue boxes)
    // isLatestStep: if true, show redex indicators; if false, hide them (historical steps)
    function renderExprToHTML(expr, depth, stepIndex, inSubstitution, nextReducedId, redexClickHandler, paramUseNodes = new Set(), isLatestStep = false) {
      const depthClass = getDepthClass(depth);

      // Check if this node starts a substitution (is substituted but parent wasn't)
      const startsSubstitution = expr.fromSubstitution && !inSubstitution;

      if (startsSubstitution) {
        // Wrap the entire substituted subtree in one box
        const wrapper = document.createElement('span');
        wrapper.className = 'substitution-box';
        wrapper.dataset.sourceId = expr.sourceId;
        wrapper.dataset.stepIndex = stepIndex;

        // Render the content inside (now we're "in" a substitution)
        const inner = renderExprToHTML(expr, depth, stepIndex, true, nextReducedId, redexClickHandler, paramUseNodes, isLatestStep);
        wrapper.appendChild(inner);
        return wrapper;
      }

      switch (expr.type) {
        case 'variable': {
          const span = document.createElement('span');
          span.textContent = expr.name;
          // Check if this variable is a parameter use (for blue box)
          if (paramUseNodes.has(expr)) {
            const wrapper = document.createElement('span');
            wrapper.className = 'param-use-box';
            wrapper.dataset.redexId = nextReducedId;
            wrapper.dataset.stepIndex = stepIndex;
            wrapper.appendChild(span);
            return wrapper;
          }
          return span;
        }

        case 'abstraction': {
          const container = document.createDocumentFragment();
          const lambdaText = document.createElement('span');
          lambdaText.textContent = '\u03BB' + expr.param + '.';
          container.appendChild(lambdaText);
          container.appendChild(renderExprToHTML(expr.body, depth, stepIndex, inSubstitution, nextReducedId, redexClickHandler, paramUseNodes, isLatestStep));
          return container;
        }

        case 'application': {
          const container = document.createDocumentFragment();

          const openParen = document.createElement('span');
          openParen.className = `paren ${depthClass}`;
          openParen.textContent = '(';

          const closeParen = document.createElement('span');
          closeParen.className = `paren ${depthClass}`;
          closeParen.textContent = ')';

          // Wrap func and arg in spans so they're always single elements
          const funcWrapper = document.createElement('span');
          funcWrapper.className = 'func';
          funcWrapper.appendChild(renderExprToHTML(expr.func, depth + 1, stepIndex, inSubstitution, nextReducedId, redexClickHandler, paramUseNodes, isLatestStep));

          const argWrapper = document.createElement('span');
          argWrapper.className = 'arg';
          // Add data attributes for linking if this is a redex
          if (expr.id !== null) {
            argWrapper.dataset.redexId = expr.id;
            argWrapper.dataset.stepIndex = stepIndex;
            // If next step reduced this redex, highlight the argument as source
            if (expr.id === nextReducedId) {
              argWrapper.classList.add('source-highlight');
            }
          }
          argWrapper.appendChild(renderExprToHTML(expr.arg, depth + 1, stepIndex, inSubstitution, nextReducedId, redexClickHandler, paramUseNodes, isLatestStep));

          container.appendChild(openParen);
          container.appendChild(funcWrapper);
          container.appendChild(document.createTextNode(' '));
          container.appendChild(argWrapper);
          container.appendChild(closeParen);

          // Add redex indicator if this is a redex (only on latest step)
          if (expr.id !== null && isLatestStep) {
            const indicator = document.createElement('span');
            indicator.className = `redex-indicator ${depthClass}`;
            indicator.textContent = expr.id;
            indicator.title = `Reduce redex ${expr.id}`;
            indicator.onclick = (e) => {
              e.stopPropagation();
              redexClickHandler(expr.id);
            };
            container.appendChild(indicator);
          }

          return container;
        }
      }
    }

    function createStepMessage(step, stepIndex) {
      const msg = document.createElement('div');
      msg.className = 'message';
      msg.dataset.stepIndex = stepIndex;

      // Header
      const header = document.createElement('div');
      header.className = 'message-header';

      const badge = document.createElement('span');
      badge.className = 'step-badge';
      badge.textContent = step.stepNum === 0 ? 'Start' : `Step ${step.stepNum}`;
      header.appendChild(badge);

      if (step.reducedId !== null) {
        const info = document.createElement('span');
        info.className = 'reduction-info';
        info.textContent = `reduced [${step.reducedId}]`;
        header.appendChild(info);

        // Show discarded arg indicator if the argument wasn't used
        if (step.discardedArg !== null) {
          const discarded = document.createElement('span');
          discarded.className = 'discarded-arg';
          discarded.title = 'Argument not used in function body (discarded)';
          discarded.innerHTML = `<span class="discarded-label">discarded:</span> <code>${escapeHtml(step.discardedArg)}</code>`;
          header.appendChild(discarded);
        }
      }

      msg.appendChild(header);

      // Expression content in pre element
      const content = document.createElement('div');
      content.className = 'expression-content';

      // Check if next step reduced a redex from this step (for source highlighting)
      const nextReducedId = steps[stepIndex + 1]?.reducedId ?? null;

      // Get parameter uses for blue box highlighting
      let paramUseNodes = new Set();
      if (nextReducedId !== null) {
        const redex = getRedex(step.expr, nextReducedId);
        if (redex) {
          const uses = getParameterUses(redex);
          paramUseNodes = new Set(uses);
        }
      }

      const isLatestStep = stepIndex === steps.length - 1;

      const pre = document.createElement('pre');
      pre.className = 'expression-pre';
      pre.appendChild(renderExprToHTML(step.expr, 0, stepIndex, false, nextReducedId, handleReduce, paramUseNodes, isLatestStep));
      content.appendChild(pre);
      msg.appendChild(content);

      // Redex choices (only for most recent step)
      const redexCount = getRedexCount(step.expr);
      if (stepIndex === steps.length - 1) {
        const redexLine = document.createElement('div');
        redexLine.className = 'redex-line';

        if (redexCount === 0) {
          const normalBadge = document.createElement('span');
          normalBadge.className = 'normal-form-badge';
          normalBadge.textContent = 'Normal form reached';
          redexLine.appendChild(normalBadge);
        } else {
          const label = document.createElement('span');
          label.className = 'redex-label';
          label.textContent = 'Reduce:';
          redexLine.appendChild(label);

          for (let i = 1; i <= redexCount; i++) {
            const btn = document.createElement('button');
            btn.className = `redex-choice ${getDepthClass(i - 1)}`;
            btn.textContent = `[${i}]`;
            btn.onclick = () => handleReduce(i);
            redexLine.appendChild(btn);
          }
        }

        msg.appendChild(redexLine);
      }

      return msg;
    }

    function renderConversation() {
      const conv = document.getElementById('conversation');
      conv.innerHTML = '';

      if (steps.length === 0) {
        const sysMsg = document.createElement('div');
        sysMsg.className = 'message system-message';
        sysMsg.innerHTML = `
          Enter a lambda expression below or choose from examples to begin.
          <br><br>
          <strong>Syntax:</strong> <code>\\x.body</code> or <code>\u03BBx.body</code> for lambda, <code>(f x)</code> for application
        `;
        conv.appendChild(sysMsg);
      } else {
        steps.forEach((step, i) => {
          conv.appendChild(createStepMessage(step, i));
        });
      }

      // Setup hover highlighting for substitution boxes
      setupSubstitutionHover();

      // Scroll to bottom
      conv.scrollTop = conv.scrollHeight;
    }

    function setupSubstitutionHover() {
      // Clear all highlights helper
      function clearHighlights() {
        document.querySelectorAll('.substitution-box.highlight').forEach(s => {
          s.classList.remove('highlight');
        });
        document.querySelectorAll('.source-hover').forEach(s => {
          s.classList.remove('source-hover');
        });
        document.querySelectorAll('.param-use-box.highlight').forEach(s => {
          s.classList.remove('highlight');
        });
      }

      // Hover on RED boxes highlights:
      // 1. All red boxes from the same source in the same step
      // 2. The corresponding yellow source box in the previous step
      const redBoxes = document.querySelectorAll('.substitution-box');
      redBoxes.forEach(el => {
        const sourceId = el.dataset.sourceId;
        const stepIndex = parseInt(el.dataset.stepIndex);

        el.addEventListener('mouseenter', () => {
          // Highlight all red boxes with same source in current step
          document.querySelectorAll(`.substitution-box[data-source-id="${sourceId}"][data-step-index="${stepIndex}"]`).forEach(s => {
            s.classList.add('highlight');
          });

          // Highlight the corresponding yellow source box in previous step
          // The sourceId tells us which redex was reduced to create this substitution
          // That redex existed in step (stepIndex - 1) with id = sourceId
          if (stepIndex > 0) {
            const prevStepIndex = stepIndex - 1;
            // Find the arg wrapper for that redex in the previous step
            const sourceArg = document.querySelector(`.arg[data-redex-id="${sourceId}"][data-step-index="${prevStepIndex}"]`);
            if (sourceArg) {
              sourceArg.classList.add('source-hover');
            }
            // Highlight all blue boxes in previous step
            document.querySelectorAll(`.param-use-box[data-redex-id="${sourceId}"][data-step-index="${prevStepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });
          }
        });

        el.addEventListener('mouseleave', clearHighlights);
      });

      // Hover on YELLOW boxes highlights:
      // All corresponding red boxes in the next step
      const yellowBoxes = document.querySelectorAll('.source-highlight');
      yellowBoxes.forEach(el => {
        el.addEventListener('mouseenter', () => {
          const redexId = el.dataset.redexId;
          const stepIndex = parseInt(el.dataset.stepIndex);

          if (redexId !== undefined) {
            const nextStepIndex = stepIndex + 1;
            // Highlight all red boxes in next step that came from this redex
            document.querySelectorAll(`.substitution-box[data-source-id="${redexId}"][data-step-index="${nextStepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });
            // Highlight all blue boxes in same step
            document.querySelectorAll(`.param-use-box[data-redex-id="${redexId}"][data-step-index="${stepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });
          }
          // Also highlight this yellow box
          el.classList.add('source-hover');
        });

        el.addEventListener('mouseleave', clearHighlights);
      });

      // Hover on BLUE boxes (parameter uses) highlights:
      // 1. All blue boxes with same redex ID in same step
      // 2. Yellow source box in same step
      // 3. Red boxes in next step
      const blueBoxes = document.querySelectorAll('.param-use-box');
      blueBoxes.forEach(el => {
        el.addEventListener('mouseenter', () => {
          const redexId = el.dataset.redexId;
          const stepIndex = parseInt(el.dataset.stepIndex);

          if (redexId !== undefined) {
            // Highlight all blue boxes with same redex ID in same step
            document.querySelectorAll(`.param-use-box[data-redex-id="${redexId}"][data-step-index="${stepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });

            // Highlight the yellow source box in same step
            const sourceArg = document.querySelector(`.arg[data-redex-id="${redexId}"][data-step-index="${stepIndex}"]`);
            if (sourceArg) {
              sourceArg.classList.add('source-hover');
            }

            // Highlight all red boxes in next step
            const nextStepIndex = stepIndex + 1;
            document.querySelectorAll(`.substitution-box[data-source-id="${redexId}"][data-step-index="${nextStepIndex}"]`).forEach(s => {
              s.classList.add('highlight');
            });
          }
        });

        el.addEventListener('mouseleave', clearHighlights);
      });
    }

    function handleReduce(id) {
      if (!currentExpr || steps.length === 0) return;

      // Clear marks on currentExpr before reducing (so new marks are fresh)
      currentExpr = clearSubstitutionMarks(currentExpr);
      currentExpr = numberRedexes(currentExpr);

      // Check if the argument will be used (before reducing)
      const redex = getRedex(currentExpr, id);
      const wasUsed = redex ? isArgumentUsed(redex) : true;
      const discardedArg = !wasUsed && redex ? toPlainString(redex.arg) : null;

      // Perform reduction - this adds substitution marks
      currentExpr = reduceAt(currentExpr, id);
      currentExpr = numberRedexes(currentExpr);

      // Add new step - keep substitution marks for history
      steps.push({
        expr: currentExpr,
        exprString: toPlainString(currentExpr),
        reducedId: id,
        stepNum: steps.length,
        discardedArg  // null if used, otherwise the string representation
      });

      renderConversation();
    }

    function loadExpression(exprString) {
      try {
        currentExpr = parse(exprString);
        currentExpr = numberRedexes(currentExpr);

        steps = [{
          expr: currentExpr,
          exprString: exprString,
          reducedId: null,
          stepNum: 0
        }];

        renderConversation();
        updateUIState();
        document.getElementById('lambda-input').value = '';
      } catch (e) {
        // Show error as system message
        const conv = document.getElementById('conversation');
        const errMsg = document.createElement('div');
        errMsg.className = 'message system-message';
        errMsg.textContent = `Parse error: ${e.message}`;
        errMsg.style.color = '#ff6b6b';
        conv.appendChild(errMsg);
        conv.scrollTop = conv.scrollHeight;
      }
    }

    function submitExpression() {
      const input = document.getElementById('lambda-input');
      const value = input.value.trim();

      if (!value) return;

      // Check if it's a number (redex selection)
      const num = parseInt(value, 10);
      if (!isNaN(num) && currentExpr) {
        const redexCount = getRedexCount(currentExpr);
        if (num >= 1 && num <= redexCount) {
          input.value = '';
          handleReduce(num);
          return;
        }
      }

      // Otherwise treat as new expression
      loadExpression(value);
    }

    function resetConversation() {
      steps = [];
      currentExpr = null;
      renderConversation();
      updateUIState();
      document.getElementById('lambda-input').focus();
    }

    function updateUIState() {
      const inputArea = document.getElementById('input-area');
      const clearBtn = document.getElementById('clear-btn');
      const isReducing = steps.length > 0;

      // Hide input area during reduction, show clear button
      inputArea.style.visibility = isReducing ? 'collapse' : 'visible';
      clearBtn.style.visibility = isReducing ? 'visible' : 'collapse';
    }

    function showExamples() {
      document.getElementById('examples-modal').classList.add('visible');
    }

    function hideExamples(e) {
      if (e.target.id === 'examples-modal') {
        document.getElementById('examples-modal').classList.remove('visible');
      }
    }

    function selectExample(expr) {
      document.getElementById('examples-modal').classList.remove('visible');
      loadExpression(expr);
    }

    // Initialize
    function init() {
      // Populate examples
      const list = document.getElementById('examples-list');
      EXAMPLES.forEach(ex => {
        const item = document.createElement('div');
        item.className = 'example-item';
        item.innerHTML = `
          <div class="name">${ex.name}</div>
          <div class="desc">${ex.description}</div>
          <div class="expr">${ex.expr}</div>
        `;
        item.onclick = () => selectExample(ex.expr);
        list.appendChild(item);
      });

      // Handle enter key on input
      document.getElementById('lambda-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') submitExpression();
      });

      // Keyboard shortcuts for reduction choices (1-9) and global shortcuts
      document.addEventListener('keydown', (e) => {
        const input = document.getElementById('lambda-input');
        const modal = document.getElementById('examples-modal');

        // Ctrl-E: Show examples (works anywhere)
        if (e.ctrlKey && (e.key === 'e' || e.key === 'E')) {
          e.preventDefault();
          if (modal.classList.contains('visible')) {
            document.getElementById('examples-modal').classList.remove('visible');
          } else {
            showExamples();
          }
          return;
        }

        // Ctrl-R: Reduce/submit expression (works anywhere except modal)
        if (e.ctrlKey && (e.key === 'r' || e.key === 'R')) {
          if (!modal.classList.contains('visible')) {
            e.preventDefault();
            submitExpression();
          }
          return;
        }

        // Escape key clears the reduction or closes modal
        if (e.key === 'Escape') {
          if (modal.classList.contains('visible')) {
            e.preventDefault();
            document.getElementById('examples-modal').classList.remove('visible');
          } else if (steps.length > 0) {
            e.preventDefault();
            resetConversation();
          }
          return;
        }

        // Don't handle number keys if typing in input or modal is open
        if (document.activeElement === input) return;
        if (modal.classList.contains('visible')) return;

        // Check for number keys 1-9
        const num = parseInt(e.key, 10);
        if (num >= 1 && num <= 9 && currentExpr) {
          const redexCount = getRedexCount(currentExpr);
          if (num <= redexCount) {
            e.preventDefault();
            handleReduce(num);
          }
        }
      });

      renderConversation();
      updateUIState();
    }

    init();
  </script>
</body>

</html>